\chapter{Supoport for reflection in Korat}
\label{ch:adding-reflection}
This chapter presents our technique for adding support for reflection
in Korat so that users can write RepOk methods that may use the Java
reflection API for accessing object fields.  Moreover, we discuss how
to allow users to exclude certain field accesses from being monitored,
as well as how to support them more easily write RepOk methods.

Recall from section \ref{sec:usage-of-reflection-for-field-access} of
Chapter~\ref{ch:shortcomings-of-korat}, the use of reflection for
field accesses in a \emph{RepOk} method may render the original Korat
implementation unable to generate some valid structures.  Reflection
causes Korat to terminate its search early because Korat is unable to
create the state-space necessary to explore possible values for fields
that are accessed using reflection, thereby causing Korat to evaluate
lesser candidate structures than necessary and therefore outputting
lesser number of valid structures.

\para In Section~\ref{sec:instrumentation-of-field-accesses} we
outline the basic technique used by Korat to monitor field accesses.
In Section~\ref{sec:adding-reflection-to-instrumentation} we present
our technique that builds on Korat's instrumentation to monitor field
accesses made using the Java reflection API. In
Section~\ref{ch:unaccounted-field-accesses} we describe how to allow
users to exclude certain field accesses from being monitored; we term
such access an \emph{unaccounted field access}; such accesses are
useful, for example, to log desired field values.  In
Section~\ref{sec:code-reuse-with-reflection} we discuss how the use of
reflection can provide code re-use for writing parts of RepOk methods.

\section{Instrumentation of field accesses}
\label{sec:instrumentation-of-field-accesses}
Korat monitors direct field accesses by using bytecode instrumention
of the code written by the user.  Korat instruments all classes whose
objects appear in the \emph{finitization} method written by the
user. Korat uses the observer pattern \cite{gamma1994design} to
monitor executions of the \emph{RepOk} method (and transitively
invoked methods) to build a stack of accessed fields. For each class,
the instrumentation adds a special constructor and a field for the
observer.

\para For ease of exposition, we illustrate the instrumentation at the
source-code level using an example from Marinov's
dissertation~\cite{marinov2005automatic} (Figure~\ref{fig:btTreeInstrumentationKorat}).
For each declared field, the instrumentation adds an identifier field
and getter/setter methods for the field. Finally, in the code for the
\emph{RepOk} method and all the methods that the \emph{RepOk}
transitively invokes (omitted in the figure), the instrumentation
replaces each read/write of the field with the generated getter/setter
methods respectively.

\para The special constructor generated by the instrumentation
initializes the \emph{korat\_observer} field and the identifiers for all
fields. The finitization uses the special constructor to initialize
all objects with an \emph{observer} and to initialize each identifier field
to a unique integer. Other than the identifier, each field has a
\emph{korat\_get} and a \emph{korat\_set} method. During the execution of
these methods, they first notify the observer that the field is being
accessed and then actually return the field or set the value for the
field based on the method (setter/getter) invoked.


\begin{figure}
\centering
\begin{lstlisting}[language=Java]
class BinaryTree {
    korat.Observer korat_observer;  // observer for this object
    // special constructor to initialize the observer and field ids
    BinaryTree( korat.Observer observer, korat.Ids id) {
        korat_observer = observer;
        korat_id_root = id.getNextId();
        korat_id_size = id.getNextId();
    }
    Node root; // root node
    int korat_id_root; //identifier for root node
    //special get method for the root field
    Node korat_get_root(){
        korat_observer.notify_get(korat_id_root);
        return root;
    }
    //special set method for the root field
    void korat_set_root(Node value){
        korat_observer.notify_set(korat_id_root);
        root = value;
    }
    int size; // number of nodes in the tree
    int korat_id_size; //identifier for size field
    //special get method for the size field
    int korat_get_size(){ 
        korat_observer.notify_get(korat_id_size);
        return size;
    }
    //special set method for the size field
    void korat_set_size(int value){ 
        korat_observer.notify_set(korat_id_size);
        size = value;
    }
   
}
\end{lstlisting}
\caption{Instrumentation of BinaryTree class by Korat~\cite{marinov2005automatic}.}
\label{fig:btTreeInstrumentationKorat}
\end{figure}


\section{Adding reflection to Korat instrumentation}
\label{sec:adding-reflection-to-instrumentation}
Since Korat instrumentation targets direct field accesses only, it
fails to monitor field accesses that use the Java reflection API. To
suport the use of reflection, Korat instrumentation needs to replace
each access that uses reflection with a method that notifies the
field observer about the access.

Our technique introduces a small library to support field accesses
based on reflection.  Specifically, our library methods perform field
accesses using the Java reflection API and in addition also notify
Korat of the particular accesses.  Our basic algorithm to support
reflection has two steps:
\begin{enumerate}
\item Bytecode instrumentation of RepOk to performs all the steps of
  Korat's original instrumentation and in addition replace invocations
  of \texttt{get} methods from Java reflection API with invocations of
  our library methods; and
\item Execution of Korat on the resulting RepOk.
\end{enumerate}

Figure~\ref{fig:fieldClassInstrumentationMethods} shows how our
technique replaces the invocations of Java reflection API methods with
invocations of our library methods.  Each of our library methods
notifies the corresponding \emph{korat\_observer} (introduced during
instrumentation) about the field accessed.


\begin{table}[h]
\centering
\resizebox{\columnwidth}{!}{\begin{tabular}{|c|c|}
\hline
\textit{Java reflection API method} & \textit{Our library method}                  \\ \hline
\texttt{Field f, Object o;}                  & \texttt{Field f, Object o;}                           \\ \hline
\texttt{Object obj = f.get(o);}              & \texttt{Object obj = ReflectionUtils.get(o,f);}       \\ \hline
\texttt{boolean b = f.getBoolean(o);}        & \texttt{boolean b = ReflectionUtils.getBoolean(o,f);} \\ \hline
\texttt{byte by = f.getByte(o);}             & \texttt{byte by = ReflectionUtils.getByte(o,f);}      \\ \hline
\texttt{char ch = f.getChar(o);}             & \texttt{char ch = ReflectionUtils.getChar(o,f);}      \\ \hline
\texttt{double d = f.getDouble(o);}          & \texttt{double d = ReflectionUtils.getDouble(o,f);}   \\ \hline
\texttt{float fl = f.getFloat(o);}           & \texttt{float fl = ReflectionUtils.getFloat(o,f);}    \\ \hline
\texttt{int i = f.getInt(o);}                & \texttt{int i = ReflectionUtils.getInt(o,f);}         \\ \hline
\texttt{long lo = f.getLong(o);}             & \texttt{long lo = ReflectionUtils.getLong(o,f);}      \\ \hline
\texttt{short s = f.getShort(o);}            & \texttt{short s = ReflectionUtils.getShort(o,f);}     \\ \hline
\end{tabular}}
\caption{Methods of the Java reflection API that the instrumentation needs to replace with our library methods.}
\label{fig:fieldClassInstrumentationMethods}
\end{table}


\section{Unaccounted field accesses}
\label{ch:unaccounted-field-accesses}
To provide flexibility in writing RepOk methods, specifically to
support methods that may make some field accesses for logging
information purposes rather than for directly determining the input's
validity, our library provides a special method
\texttt{ReflectionUtils.unaccountedAccess(Object o,String fieldName)}
that allows accessing a field value using reflection but without
notifying Korat.

Figure~\ref{fig:bTreeUnaccountedFieldAccess} shows an example usage of
a field access that is unaccounted (for Korat search).  In this
example, the user chooses to check the current value of \texttt{size}
field and output an appropriate message (Line~\ref{line:unacc_access}) even though a
violation of acyclicity is found and there is no need to access size
to determine the input's validity.  Were Korat to be notified of this
extraneous access to \texttt{size} field, Korat would be forced to
explore additional candidate structures, which it would have otherwise
pruned from its search.  We conjecture such unaccounted field access
could assist in developing different backtracking strategies, which
for example modify more than one fields of a candidate during
backtracking to perform more aggressive pruning.

\begin{figure}
\centering
\begin{lstlisting}[language=Java,escapechar=|]
boolean repOK() throws Exception{
    // checks that empty tree has size zero.
    if (root == null) return size == 0;
    Set visited = new HashSet();
    visited.add(root);
    LinkedList workList = new LinkedList();
    workList.add(root);
    // loop checks that the object graph is a tree.
    while (!workList.isEmpty()) {
        Node current = (Node) workList.removeFirst();
        if (current.left != null) {
            if (!visited.add(current.left)) {
                // Korat’s search is not affected by the following unaccounted access
                System.out.println(“Cycle found at size : ” + (int)ReflectionUtils.unaccountedAccess(this,”size”));|\label{line:unacc_access}|
                return false;
            }
            workList.add(current.left);
        }
        if (current.right != null) {
            if (!visited.add(current.right)) return false;
            workList.add(current.right);
        }
    }
    // checks that the size is consistent.
    return (visited.size() == size);
}
\end{lstlisting}
\caption{BinaryTree repOk using unaccounted field access for logging.}
\label{fig:bTreeUnaccountedFieldAccess}
\end{figure}

\section{Code reuse with reflection}
\label{sec:code-reuse-with-reflection}
The use of reflection for making field accesses enables writing
re-usable checks for properties that are common across different data
structures, e.g., acyclicity along all the reference fields can be
written so that a singly-linked list RepOk and a binary tree RepOk
could invoke the same acyclicity check.
Figure~\ref{fig:btreeAcyclicRepOk} shows such a check for acyclicity.
Any RepOk method that uses this re-usable check as a helper method can
provide test input generation using our technique, which supports the
use of reflection.  Table~\ref{fig:libraryEvaluationTable} shows the
results for using the re-usable check for writing RepOk methods for
three subject data structures, which are all acyclic.  For each
structure, we tabulate the behavior of Korat search (1)~using
dedicated RepOk for that structure as well as (2)~using the re-usable
check.  The same numbers of candidates are explored and generated in
both cases (as expected).
\begin{figure}
\centering
\begin{lstlisting}[language=Java]
private static Set checkAcyclic(Object obj) throws Exception{
    Class<?> objClass = obj.getClass();
    Field[] objFields = objClass.getDeclaredFields();
    List<Field> matchingFields = new ArrayList<Field>();
    for(Field field : objFields){
        if(field.getType().equals(objClass)){
            matchingFields.add(field);
        }
    }
    Set visited = new HashSet();
    visited.add(obj);
    LinkedList workList = new LinkedList();
    workList.add(obj);
    while (!workList.isEmpty()) {
        Object current = workList.removeFirst();
        for(Field field : matchingFields){
            if(getFieldValue(current, field.getName()) != null){
                if(!visited.add(getFieldValue(current, field.getName()))) return null;
                workList.add(getFieldValue(current, field.getName()));
            }
        }
    }
    return visited;
}

boolean repOK() throws Exception{
    // checks that empty tree has size zero.
    if (root == null) return size == 0;
    // checks that the object graph is a tree.
    Set nodeSet = checkAcyclic(root);
    // checks that the size is consistent.
    return (nodeSet != null && nodeSet.size() == size);
}
\end{lstlisting}
\caption{Binary tree example with RepOk using a re-usable check (checkAcyclic) written using reflection.}
\label{fig:btreeAcyclicRepOk}
\end{figure}

The idea of re-usable checks was introduced in Marinov's dissertation,
which describes dedicated generators that are library methods that
allow users to (1)~directly specify structural properties without
having the explicitly implement the corresponding checks; and
(2)~achieve faster generation due to customized solving for those
properties.  Our support for reflection allows the users to define
re-usable checks simply using the standard Java reflection API and
utilize the standard Korat algorithm.


\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
 & \multicolumn{3}{c|}{\textit{\begin{tabular}[c]{@{}c@{}}\# of structures \\ explored/valid \\ using a \\ specialized RepOk\end{tabular}}} & \multicolumn{3}{c|}{\textit{\begin{tabular}[c]{@{}c@{}}\# of structures \\ explored/valid \\ using a \\ re-usable check\end{tabular}}} \\ \hline
\textit{Scope size} & 5 & 6 & 7 & 5 & 6 & 7 \\ \hline
\textit{BinaryTree} & \begin{tabular}[c]{@{}c@{}}1272/\\ 65\end{tabular} & \begin{tabular}[c]{@{}c@{}}4835/\\ 197\end{tabular} & \begin{tabular}[c]{@{}c@{}}18474/\\ 626\end{tabular} & \begin{tabular}[c]{@{}c@{}}1272/\\ 65\end{tabular} & \begin{tabular}[c]{@{}c@{}}4835/\\ 197\end{tabular} & \begin{tabular}[c]{@{}c@{}}18474/\\ 626\end{tabular} \\ \hline
\textit{LinkedList} & \begin{tabular}[c]{@{}c@{}}259/\\ 24\end{tabular} & \begin{tabular}[c]{@{}c@{}}974/\\ 76\end{tabular} & \begin{tabular}[c]{@{}c@{}}4147/\\ 279\end{tabular} & \begin{tabular}[c]{@{}c@{}}259/\\ 24\end{tabular} & \begin{tabular}[c]{@{}c@{}}974/\\ 76\end{tabular} & \begin{tabular}[c]{@{}c@{}}4147/\\ 279\end{tabular} \\ \hline
\textit{SortedList} & \begin{tabular}[c]{@{}c@{}}507/\\ 126\end{tabular} & \begin{tabular}[c]{@{}c@{}}2100/\\ 462\end{tabular} & \begin{tabular}[c]{@{}c@{}}9167/\\ 1716\end{tabular} & \begin{tabular}[c]{@{}c@{}}507/\\ 126\end{tabular} & \begin{tabular}[c]{@{}c@{}}2100/\\ 462\end{tabular} & \begin{tabular}[c]{@{}c@{}}9167/\\ 1716\end{tabular} \\ \hline
\end{tabular}
\caption{Number of valid structures generated by Korat using specialized RepOk's and re-usable checks. All maximum finitization parameters are set to the size value.}
\label{fig:libraryEvaluationTable}
\end{table}
