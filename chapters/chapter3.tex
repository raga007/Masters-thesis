\chapter{Adding reflection support to Korat}
\label{ch:adding-reflection}
In this chapter, we will discuss a technique that builds on Korat to
allow the use of reflection for field accesses by \emph{RepOk}. Recall
from section \ref{sec:usage-of-reflection-for-field-access} of chapter
\ref{ch:shortcomings-of-korat}, the use of reflection for field
accesses in a \emph{RepOk} method may render Korat unable to generate
some valid structures. When reflection is used for field access, Korat
terminates its search early as it has no way to account for the field
access made using reflection. Korat evaluates lesser candidate
structures than expected and therefore outputs lesser number of valid
structures.

\para In section \ref{sec:instrumentation-of-field-accesses} we
introduce the technique used by Korat to monitor field accesses. In
section \ref{sec:adding-reflection-to-instrumentation} we discuss a
technique to build on Korat's instrumentation to monitor field
accesses that use the Java reflection API. In section
\ref{ch:unaccounted-field-accesses} we present a method that can be
used to make a feild access that doesn't affect Korat's search
algorithm. We call it an \emph{unaccounted field access} and it is
useful when the field access is used for something that does not
affect the output of the \emph{RepOk}. For example, the method can be
used for logging values during the search. Finally in section
\ref{sec:code-reuse-with-reflection} we discuss about how using
reflection in \emph{RepOk} implementations can help enabling code
reuse, due to the generic nature of reflection.

\section{Instrumentation of field accesses}
\label{sec:instrumentation-of-field-accesses}
Korat monitors direct field accesses by instrumenting the code written
by the user. Korat performs source-source translation that instruments
all classes whose objects appear in the \emph{finitization} method
written by the user. Korat uses the observer pattern
\cite{gamma1994design} to monitor executions of the \emph{RepOk}
method (and transitively invoked methods) to build a stack of accessed
fields. For each class, the instrumentation adds a special constructor
and a field for the observer, as shown in figure
\ref{fig:btTreeInstrumentationKorat}. For each field in a class, the
instrumentation adds an identifier field and getter/setter methods for
the field. Finally, in the code for the \emph{RepOk} method and all
the methods that the \emph{RepOk} transitively invokes, the
instrumentation replaces each read/write of the field with the
generated getter/setter methods respectively.

\para The special constructor generated by the instrumentation
initializes the \emph{korat\_observer} field and the identifiers for all
fields. The finitization uses the special constructor to initialize
all objects with an \emph{observer} and to initialize each identifier field
to a unique integer. Other than the identifier, each field has a
\emph{korat\_get} and a \emph{korat\_set} method. During the execution of
these methods, they first notify the observer that the field is being
accessed and then actually return the field or set the value for the
field based on the method (setter/getter) invoked.


\begin{figure}
\centering
\begin{lstlisting}[language=Java]
class BinaryTree {
    korat.Observer korat_observer;  // observer for this object
    // special constructor to initialize the observer and field ids
    BinaryTree( korat.Observer observer, korat.Ids id) {
        korat_observer = observer;
        korat_id_root = id.getNextId();
        korat_id_size = id.getNextId();
    }
    Node root; // root node
    int korat_id_root; //identifier for root node
    //special get method for the root field
    Node korat_get_root(){
        korat_observer.notify_get(korat_id_root);
        return root;
    }
    //special set method for the root field
    void korat_set_root(Node value){
        korat_observer.notify_set(korat_id_root);
        root = value;
    }
    int size; // number of nodes in the tree
    int korat_id_size; //identifier for size field
    //special get method for the size field
    int korat_get_size(){ 
        korat_observer.notify_get(korat_id_size);
        return size;
    }
    //special set method for the size field
    void korat_set_size(int value){ 
        korat_observer.notify_set(korat_id_size);
        size = value;
    }
   
    // a repOk where all the field accesses are 
    // replaced with the korat getter and setter methods.
}
\end{lstlisting}
\caption{Instrumentation of BinaryTree class by Korat.}
\label{fig:btTreeInstrumentationKorat}
\end{figure}


\section{Adding reflection to Korat instrumentation}
\label{sec:adding-reflection-to-instrumentation}
Korat fails to monitor field accesses that use the Java reflection
API. In order to instrument field accesses that use the Java
reflection API, Korat instrumentation needs to replace each read/write
that uses reflection with a method that notifies the field observer
about the access. 

\para The \emph{getFieldValue} method from the \emph{ReflectionUtils}
class (shown in figure \ref{fig:fieldClassInstrumentationMethods})
notifies the corresponding \emph{korat\_observer} for the field
accessed using the method. Figure
\ref{fig:fieldClassInstrumentationMethods} shows all the methods in
the \emph{java.reflect.Field} class that can used to access a field
using the Java reflection API. The figure does not show methods that
can be used to set the value of field using reflection. The Korat
instrumentation needs to look for invocation of these methods in the
\emph{RepOk} method and replace them with the getFieldValue method as
shown in figure \ref{fig:fieldClassInstrumentationMethods}. This will
make Korat account for the field access made using the Java reflection
API and the Korat search will perform as expected when reflection is
used in the \emph{RepOk} implementation.

\begin{figure}
\centering
\begin{lstlisting}[language=Java]
//method call that makes Korat account for field access that uses the Java reflection API.
Object obj = ReflectionUtils.getFieldValue(Object obj, Field field);

//different ways to access a field using Java Reflection API
Field field = BinaryTree.class.getDeclaredField(``left'');
Object obj = field.get(Object obj);
boolean obj = field.getBoolean(Object obj)
byte obj = field.getByte(Object obj)
char obj = field.getChar(Object obj)
double obj = field.getDouble(Object obj)
float obj = field.getFloat(Object obj)
int obj = field.getInt(Object obj)
long obj = field.getLong(Object obj)
short obj = field.getShort(Object obj)

// Instrumentation replaces the java reflection API call with our API call
field.get(obj) -> ReflectionUtils.getFieldValue(obj,field);
\end{lstlisting}
\caption{Methods of the field class that the instrumentation needs to replace with the getFieldValue method.}
\label{fig:fieldClassInstrumentationMethods}
\end{figure}

\section{Unaccounted field accesses}
\label{ch:unaccounted-field-accesses}
Recall, Korat monitors all field accesses by instrumenting the
\emph{RepOk} method written by the user. Recall from section
\ref{sec:inefficient-predicates} that a poorly-written \emph{RepOk}
may adversely affect the performance of Korat and force it to explore
many more states than necessary. A poorly-written written \emph{RepOk}
method accesses fields even after the result of the \emph{RepOk} is
decided. There may be situations where the programmer wants to access
a field inside the \emph{RepOk} method for reasons that don't affect
the result of the \emph{RepOk} method. For example, the programmer may
want to log the value of a field or notify an external observer about
a change in a field. Since Korat monitors all field accesses by
insrumenting them, we provide a method for field access that can be
used in situations where the user does not want the Korat search to be
affected by the field access.

\para The \emph{unaccountedAccess} method in the ReflectionUtils class
offers a way to access a field without accounting for its access. This
method uses the Java reflection API to access the field. Recall, Korat
instrumentation doesn't instrument field accesses made using the Java
reflection API. The instrumentation technique presented in section
\ref{adding-reflection-to-instrumentation} ignores instrumenting the
\emph{unaccountedAccess} method and therefore the field access made by
the \emph{unaccountedAccess} method does not affect the Korat search
algorithm. Figure \ref{fig:bTreeUnaccountedFieldAccess} shows an
example usage of the method for logging. 

\begin{figure}
\centering
\begin{lstlisting}[language=Java]
boolean repOK() {
    // checks that empty tree has size zero.
    if (root == null) return size == 0;
    Set visited = new HashSet();
    visited.add(root);
    LinkedList workList = new LinkedList();
    workList.add(root);
    // loop checks that the object graph is a tree.
    while (!workList.isEmpty()) {
        Node current = (Node) workList.removeFirst();
        if (current.left != null) {
            if (!visited.add(current.left)) return false;
            workList.add(current.left);
        }
        if (current.right != null) {
            if (!visited.add(current.right)) return false;
            workList.add(current.right);
        }
    }
    // Korat’s search is not affected by the following access.
    if(visited.size() != (int)ReflectionUtils.unaccountedAccess(this,”size”)){
        System.out.println(“Size mismatch, need to change size”);
    }
    // checks that the size is consistent.
    return (visited.size() == size);
}
\end{lstlisting}
\caption{BinaryTree repOk using unaccounted field access for logging.}
\label{fig:bTreeUnaccountedFieldAccess}
\end{figure}

\section{Code reuse with reflection}
\label{sec:code-reuse-with-reflection}
In this section we present how using reflection can enable code reuse
and avoid code bloat in \emph{RepOk} methods. Figure
\ref{fig:btreeAcyclicRepOk} shows the implementation of a method that
can be be used to check the acyclicity property of an object graph. A
generic implemtation like \emph{checkAcyclic} can be reused to check
the acyclicity of many recursive datastructures like BinaryTree,
LinkedList, Graph etc. Figure \ref{fig:btreeAcyclicRepOk} also shows a
\emph{RepOk} implementation for a BinaryTree that uses the
\emph{checkAcyclic} method.

\para Using reflection in \emph{RepOk} implementations allows code
reuse and also reduces code bloat. Therefore it makes it easier to
write a library of methods that can potentially help the programmer in
writing \emph{RepOk} methods for complex data structures. Figure
\ref{fig:libraryEvaluationTable}  presents a comparision between the number of valid
structures output by Korat when the \emph{RepOk} methods use the
\emph{checkAcyclicity(Object o)} method and don't use the method (from
Korat distribution) to check if the object graph is acyclic. It was
observed that both sets of implementations of \emph{RepOk} methods
evaluate the same number of candidate structures and output the same
number of valid structures. We observed a very negligible (less than
0.1 seconds) execution time difference between the \emph{RepOk}
implementations presented.


\begin{figure}
\centering
\begin{lstlisting}[language=Java]
private static Set checkAcyclic(Object obj){
    Class<?> objClass = obj.getClass();
    Field[] objFields = objClass.getDeclaredFields();
    List<Field> matchingFields = new ArrayList<Field>();
    for(Field field : objFields){
        if(field.getType().equals(objClass)){
            matchingFields.add(field);
        }
    }
    Set visited = new HashSet();
    visited.add(obj);
    LinkedList workList = new LinkedList();
    workList.add(obj);
    while (!workList.isEmpty()) {
        Object current = workList.removeFirst();
        for(Field field : matchingFields){
            if(getFieldValue(current, field.getName()) != null){
                if(!visited.add(getFieldValue(current, field.getName()))) return null;
                workList.add(getFieldValue(current, field.getName()));
            }
        }
    }
    return visited;
}

boolean repOK() {
    // checks that empty tree has size zero.
    if (root == null) return size == 0;
    // checks that the object graph is a tree.
    Set nodeSet = checkAcyclic(root);
    // checks that the size is consistent.
    return (nodeSet != null && nodeSet.size() == size);
}
\end{lstlisting}
\caption{Binary tree example with RepOk using a generic checkAcyclic method written using reflection.}
\label{fig:btreeAcyclicRepOk}
\end{figure}



\begin{table}[h]
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
 & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures \\ explored/valid \\ without code reuse\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures \\ explored/valid \\ with code reuse\end{tabular}} \\ \hline
Scope size & 5 & 6 & 7 & 5 & 6 & 7 \\ \hline
BinaryTree & \begin{tabular}[c]{@{}c@{}}1272/\\ 65\end{tabular} & \begin{tabular}[c]{@{}c@{}}4835/\\ 197\end{tabular} & \begin{tabular}[c]{@{}c@{}}18474/\\ 626\end{tabular} & \begin{tabular}[c]{@{}c@{}}1272/\\ 65\end{tabular} & \begin{tabular}[c]{@{}c@{}}4835/\\ 197\end{tabular} & \begin{tabular}[c]{@{}c@{}}18474/\\ 626\end{tabular} \\ \hline
LinkedList & \begin{tabular}[c]{@{}c@{}}259/\\ 24\end{tabular} & \begin{tabular}[c]{@{}c@{}}974/\\ 76\end{tabular} & \begin{tabular}[c]{@{}c@{}}4147/\\ 279\end{tabular} & \begin{tabular}[c]{@{}c@{}}259/\\ 24\end{tabular} & \begin{tabular}[c]{@{}c@{}}974/\\ 76\end{tabular} & \begin{tabular}[c]{@{}c@{}}4147/\\ 279\end{tabular} \\ \hline
SortedList & \begin{tabular}[c]{@{}c@{}}507/\\ 126\end{tabular} & \begin{tabular}[c]{@{}c@{}}2100/\\ 462\end{tabular} & \begin{tabular}[c]{@{}c@{}}9167/\\ 1716\end{tabular} & \begin{tabular}[c]{@{}c@{}}507/\\ 126\end{tabular} & \begin{tabular}[c]{@{}c@{}}2100/\\ 462\end{tabular} & \begin{tabular}[c]{@{}c@{}}9167/\\ 1716\end{tabular} \\ \hline
\end{tabular}
\caption{Number of valid structures generated by Korat when library for predicates is used in RepOk. All maximum finitization parameters are set to the size value.}
\label{fig:libraryEvaluationTable}
\end{table}
