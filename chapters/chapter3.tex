\chapter{Adding reflection to Korat}
In this chapter, we will look at the reflection support added in the improvised Korat. In section 2.1 of chapter 2, we observed that using reflection for field accesses inside the predicate written by the user will make korat terminate its search before it finishes exploring all the states. This is because, the field accesses are not accounted for and Korat’s search algorithm primarily depends on monitoring field accesses.

\section{Instrumentation of field accesses}
Korat monitors direct field accesses by instrumenting the code written by the user. Korat performs source-source translation that instruments all classes whose objects appear in finitizations. Korat uses the observer pattern ~/cite{...} to monitor executions of the predicate (and transitively invoked methods) to build a stack of accessed fields. For each class, the instrumentation adds a special constructor and a field for the observer, as shown in figure 3-1. For each field in a class, the instrumentation adds an identifier field and getter/setter methods for the field. Finally, in the code for repOk and all the methods that repOk transitively invokes, the instrumentation replaces each read/write of the field with the generated getter/setter methods respectively.

\par
The special constructor generated by the instrumentation initializes the korat\_observer field and the identifiers for all fields. The finitization uses the special constructor to initialize all objects with an observer and to initialize each identifier field to a unique integer. Other than the identifier, each field has a korat\_get and a korat\_set method method. During the execution of these methods, they first notify the observer that the field is being accessed and then actually return the field or set the value for the field based on the setter/getter invoked.


\begin{figure}
\centering
\begin{lstlisting}[language=Java]
class BinaryTree {
    korat.Observer korat_observer;  // observer for this object
    // special constructor to initialize the observer and field ids
    BinaryTree( korat.Observer observer, korat.Ids id) {
        korat_observer = observer;
        korat_id_root = id.getNextId();
        korat_id_size = id.getNextId();
    }
    Node root; // root node
    int korat_id_root; //identifier for root node
    //special get method for the root field
    Node korat_get_root(){
        korat_observer.notify_get(korat_id_root);
        return root;
    }
    //special set method for the root field
    void korat_set_root(Node value){
        korat_observer.notify_set(korat_id_root);
        root = value;
    }
    int size; // number of nodes in the tree
    int korat_id_size; //identifier for size field
    //special get method for the size field
    int korat_get_size(){ 
        korat_observer.notify_get(korat_id_size);
        return size;
    }
    //special set method for the size field
    void korat_set_size(int value){ 
        korat_observer.notify_set(korat_id_size);
        size = value;
    }
   
    // a repOk where all the field accesses are 
    // replaced with the korat getter and setter methods.
}
\end{lstlisting}
\caption{Instrumentation of BinaryTree class by Korat.}
\label{fig:btTreeInstrumentationKorat}
\end{figure}


\section{Adding reflection to Instrumentation}
Korat fails to monitor field accesses that use reflection. In order to make sure field accesses that use reflection are monitored by Korat, the instrumentation needs to make sure it accounts for reflection. Figure 3-2 shows all the methods in the java.reflect.Field class that can used to access a field using the java reflection API. The figure does not show methods that can be used to set the value of field using reflection but, it should be straightforward to find the counterparts of the getter methods from the documentation. The Korat instrumentation needs to look for invocation of these methods in the predicate written by the user and replace them with the getFieldValue method from the ReflectionUtils class as shown in figure 3-2. We haven’t modified the implementation of Korat instrumentation to account for reflection based field access. All experiments were done by manually using the getFieldValue method in place of the methods from the Field class.

\begin{figure}
\centering
\begin{lstlisting}[language=Java]
Object ReflectionUtils.getFieldValue(Object obj, String fieldName)

Object get(Object obj)
boolean getBoolean(Object obj)
byte getByte(Object obj)
char getChar(Object obj)
double getDouble(Object obj)
float getFloat(Object obj)
int getInt(Object obj)
long getLong(Object obj)
short getShort(Object obj)

\end{lstlisting}
\caption{Methods of the field class that the instrumentation needs to replace with the getFieldValue method.}
\label{fig:fieldClassInstrumentationMethods}
\end{figure}

\section{Unaccounted field accesses}
Korat monitors direct field accesses by instrumenting the code written by the user. Korat’ search algorithm is primarily dependant on field accesses and extra field accesses might lead to the decrease of efficiency of Korat, as shown in section 2.2. There can be situations where the programmer doesn’t want to use the field access to determine the result of the predicate. For example, the user just wants to log the current value of the field, or send to an external observer. Since Korat monitors every field access by instrumenting the repOk written by the user, we have provided an indirect way to get/set the value of a field without accounting for the access.

\par
The public static method unaccountedAccess in the ReflectionUtils class offers a way to access an object without accounting for its access. Since Korat already doesn’t account for reflection, we don’t have to worry about the existing instrumentation of Korat, instrumenting this method call. Figure 3-3 shows an example usage of the method for logging. It is important to note that the static analysis tool that we developed (RepOkValidator from chapter 4) also, doesn’t consider this as an access and hence doesn’t raise any violations when this method is used to access a field.


\begin{figure}
\centering
\begin{lstlisting}[language=Java]
boolean repOK() {
    // checks that empty tree has size zero.
    if (root == null) return size == 0;
    Set visited = new HashSet();
    visited.add(root);
    LinkedList workList = new LinkedList();
    workList.add(root);
    // loop checks that the object graph is a tree.
    while (!workList.isEmpty()) {
        Node current = (Node) workList.removeFirst();
        if (current.left != null) {
            if (!visited.add(current.left)) return false;
            workList.add(current.left);
        }
        if (current.right != null) {
            if (!visited.add(current.right)) return false;
            workList.add(current.right);
        }
    }
    // Korat’s search is not affected by the following access.
    if(visited.size() != (int)ReflectionUtils
             .unaccountedAccess(this,”size”)){
        System.out.println(“Size mismatch, need to change size”);
    }
    // checks that the size is consistent.
    return (visited.size() == size);
}
\end{lstlisting}
\caption{BinaryTree repOk using unaccounted field access for logging.}
\label{fig:bTreeUnaccountedFieldAccess}
\end{figure}
