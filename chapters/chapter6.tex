\chapter{Evaluation}
This chapter presents an evaluation of Korat when field accesses using reflection are not accounted for. Section 8.1 discusses the benchmark suite that we use in the evaluation. The suite consists of 5 data structure implementations. Section 8.2 presents the number of valid structures generated by Korat when reflection is used for field accesses. Improvised Korat will also account for field accesses that use reflection and therefore, will produce the same results as Korat when all field accesses are direct. We performed all experiments on an OSX machine with a  2.7Ghz, intel core i7 processor using Sunâ€™s Java 6 SDK 1.6.0 JVM.

\section{Benchmarks}
Figure 6-1 shows the benchmarks that we used in our experiments. The benchmarks include implementations of text-book data structures and some data structures from the JCF (Java Collections Framework) that is a part of the standard java libraries ~/cite{...}. The names used for the benchmarks are from the Intentional naming system ~cite{...}.

\begin{table}[h]
\begin{tabular}{|c|c|c|}
\hline
Benchmark    & Package        & Finitization parameters                \\ \hline
BinaryTree   & korat.examples & numNodes, minSize, maxSize             \\ \hline
RedBlackTree & korat.examples & numEntries, minSize, maxSize, numKeys  \\ \hline
LinkedList   & java.util      & numEntries, minSize, maxSize, numElems \\ \hline
SortedList   & java.util      & numEntries, minSize, maxSize, numElems \\ \hline
HeapArray    & korat.examples & minSize, maxSize, maxLength, maxElem   \\ \hline
\end{tabular}
\label{fig:benchmarksAndFinitizationParams}
\caption{Benchmarks and finitization parameters. Each benchmark is named after the class for which data structures are generated; the structures also contain objects from other classes.}
\end{table}

\par
Following is a summary for the implementation of each benchmark : 
\begin{itemize}
\item BinaryTree is our main example we have been using all along. It is an implementation of a Binary tree.
\item HeapArray is an array-based implementation of the heap data structure. This benchmark is representative for array based data structures such as stacks and queues, as well as java.util.Vector.
\item LinkedList is an implementation of linked lists form the Java Collections Framework. This implementation uses doubly-linked, circular lists. The elements in the linked lists are arbitrary objects. This benchmark is also a representative for array based data structures.
\item SortedList is structurally identical to LinkedList but, has sorted elements.
\item RedBlackTree is a binary search tree implementation that self balances itself using a set of rules based on the color in its nodes.
\end{itemize}

\section{Generation of valid structures}
Figure 6-2 presents the results for generating valid structures for our benchmark suite, using Korat when reflection is used for zero or more field accesses. For each benchmark, we set all finitization parameters such that Korat generates structures of upto the given size. We set the maxSize and other maximum parameters to the value of size and minSize to 0. For a range of sizes, we tabulate the number of valid structures that Korat generates, the number of candidate structures that repOk checks and the time Korat takes to generate the valid structures. 

\par
We use four different repOks: one that only uses direct access to access all the required fields and the other three use reflection to access three different types of fields. The first type is a root/header field that is usually accessed very early in the repOk. The second type is a size field, that is usually accessed towards the end of the predicate. The last type is a recursive field that is accessed typically inside a loop. In each type, reflection is used to access only a single field. 

\par
The results show that korat is affected differently when reflection is used to access different fields. In cases where reflection is used to access a field early in a repOk, the Korat search terminates in under a second and ends up generating up to 2 valid structures. In the second type of repOk where the size field (typically accessed towards the end of repOk) is accessed using reflection, Korat ends exploring a lot of candidate structures but, only generates very few valid structures. This is why it is important for Korat to account for field access that use reflection. One the instrumentation starts monitoring field accesses that uses reflection, Korat will be able to generate all non-isomorphic valid structures efficiently for all the types of repOks shown in figure 6-2.

\begin{sidewaystable}[h]
\resizebox{\textheight}{!}{\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
 & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}Field access \\ without reflection\end{tabular}} & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}Reflection used for\\  ``root/header'' field access\end{tabular}} & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}Reflection used for \\ ``size'' field access\end{tabular}} & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}Reflection used for \\ a recursive field access\end{tabular}} \\ \hline
 & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures\\ explored/valid\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}Execution time \\ (in sec)\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures\\ explored/valid\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}Execution time\\ (in sec)\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures\\ explored/valid\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}Execution time\\ (in sec)\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures\\ explored/valid\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}Execution time\\ (in sec)\end{tabular}} \\ \hline
Scope size & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 \\ \hline
BinaryTree & \begin{tabular}[c]{@{}c@{}}1272/\\ 65\end{tabular} & \begin{tabular}[c]{@{}c@{}}4835/\\ 197\end{tabular} & \begin{tabular}[c]{@{}c@{}}18474/\\ 626\end{tabular} & 0.56 & 0.91 & 1.81 & \begin{tabular}[c]{@{}c@{}}7/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}8/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}9/\\ 2\end{tabular} & 0.22 & 0.21 & 0.22 & \begin{tabular}[c]{@{}c@{}}952/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}3659/\\ 7\end{tabular} & \begin{tabular}[c]{@{}c@{}}14099/\\ 8\end{tabular} & 0.49 & 0.72 & 1.41 & \begin{tabular}[c]{@{}c@{}}9/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}10/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}11/\\ 2\end{tabular} & 0.20 & 0.21 & 0.25 \\ \hline
RedBlackTree & \begin{tabular}[c]{@{}c@{}}6073/\\ 115\end{tabular} & \begin{tabular}[c]{@{}c@{}}25938/\\ 327\end{tabular} & \begin{tabular}[c]{@{}c@{}}112012/\\ 911\end{tabular} & 1.36 & 5.32 & 30.32 & \begin{tabular}[c]{@{}c@{}}9/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}10/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}11/\\ 2\end{tabular} & 0.34 & 0.27 & 0.27 & \begin{tabular}[c]{@{}c@{}}1387/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}4958/\\ 7\end{tabular} & \begin{tabular}[c]{@{}c@{}}18769/\\ 8\end{tabular} & 0.74 & 1.23 & 3.27 & \begin{tabular}[c]{@{}c@{}}16/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}18/\\ 7\end{tabular} & \begin{tabular}[c]{@{}c@{}}20/\\ 8\end{tabular} & 0.30 & 0.31 & 0.32 \\ \hline
LinkedList & \begin{tabular}[c]{@{}c@{}}259/\\ 24\end{tabular} & \begin{tabular}[c]{@{}c@{}}974/\\ 76\end{tabular} & \begin{tabular}[c]{@{}c@{}}4147/\\ 279\end{tabular} & 0.40 & 0.53 & 0.79 & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & 0.22 & 0.23 & 0.23 & \begin{tabular}[c]{@{}c@{}}144/\\ 5\end{tabular} & \begin{tabular}[c]{@{}c@{}}524/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}2201/\\ 7\end{tabular} & 0.29 & 0.45 & 0.65 & \begin{tabular}[c]{@{}c@{}}4/\\ 1\end{tabular} & \begin{tabular}[c]{@{}c@{}}4/\\ 1\end{tabular} & \begin{tabular}[c]{@{}c@{}}4/\\ 1\end{tabular} & 0.22 & 0.23 & 0.25 \\ \hline
SortedList & \begin{tabular}[c]{@{}c@{}}507/\\ 126\end{tabular} & \begin{tabular}[c]{@{}c@{}}2100/\\ 462\end{tabular} & \begin{tabular}[c]{@{}c@{}}9167/\\ 1716\end{tabular} & 0.48 & 0.81 & 1.44 & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & 0.25 & 0.24 & 0.24 & \begin{tabular}[c]{@{}c@{}}71/\\ 5\end{tabular} & \begin{tabular}[c]{@{}c@{}}95/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}122/\\ 7\end{tabular} & 0.29 & 0.31 & 0.34 & \begin{tabular}[c]{@{}c@{}}7/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}8/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}9/\\ 0\end{tabular} & 0.24 & 0.29 & 0.26 \\ \hline
HeapArray & \begin{tabular}[c]{@{}c@{}}8916/\\ 1919\end{tabular} & \begin{tabular}[c]{@{}c@{}}64533/\\ 13139\end{tabular} & \begin{tabular}[c]{@{}c@{}}519968/\\ 117562\end{tabular} & 0.92 & 3.21 & 41.63 & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & 0.20 & 0.17 & 0.18 & \begin{tabular}[c]{@{}c@{}}22/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}26/\\ 7\end{tabular} & \begin{tabular}[c]{@{}c@{}}30/\\ 8\end{tabular} & 0.20 & 0.21 & 0.19 & \begin{tabular}[c]{@{}c@{}}3/\\ 1\end{tabular} & \begin{tabular}[c]{@{}c@{}}3/\\ 1\end{tabular} & \begin{tabular}[c]{@{}c@{}}3/\\ 1\end{tabular} & 0.27 & 0.25 & 0.26 \\ \hline
\end{tabular}}
\label{fig:resultsTable}
\caption{Number of valid structures generated by Korat when reflection is used for field accesses. All maximum finitization parameters are set to the size value. Time is elapsed real time in seconds.}
\end{sidewaystable}
