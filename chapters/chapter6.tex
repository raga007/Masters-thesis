\chapter{Evaluation}
\label{ch:evaluation}
This chapter presents an evaluation of the library for predicates
presented in chapter \ref{ch:library-for-predicates} and an evaluation
of how Korat performs when reflection support is absent. Section
\ref{sec:benchmarks} discusses the benchmark suite that we use in our
evaluations. The suite consists of 5 data structure
implementations. Section \ref{sec:generation-of-valid-structures}
presents the results of experiments done with Korat without reflection
support. The results show how Korat does not output expected results
when reflection is used. Adding reflection support as discussed in
chapter \ref{ch:adding-reflection} will make Korat function as
expected when reflection is used in \emph{RepOk} predicates. Section
\ref{sec:evaluation-of-library-for-predicates} presents a comparision
between \emph{RepOk} methods written using the library for predicates
and \emph{RepOk} methods from the Korat distribution. We performed all
experiments on an OSX machine with a 2.7Ghz, intel core i7 processor
using Sunâ€™s Java 6 SDK 1.6.0 JVM.


\section{Benchmarks}
\label{sec:benchmarks}
Figure \ref{fig:benchmarksAndFinitizationParams} shows the benchmarks
that we used in our experiments. The benchmarks include
implementations of text-book data structures and some data structures
from the JCF (Java Collections Framework) that is a part of the
standard java libraries \cite{Linden:2004:JJJ:993931}. The names used for the benchmarks
are from the Intentional naming system \cite{adjie1999design}.

\begin{table}[h]
\begin{tabular}{|c|c|c|}
\hline
Benchmark    & Package        & Finitization parameters                \\ \hline
BinaryTree   & korat.examples & numNodes, minSize, maxSize             \\ \hline
RedBlackTree & korat.examples & numEntries, minSize, maxSize, numKeys  \\ \hline
LinkedList   & java.util      & numEntries, minSize, maxSize, numElems \\ \hline
SortedList   & java.util      & numEntries, minSize, maxSize, numElems \\ \hline
HeapArray    & korat.examples & minSize, maxSize, maxLength, maxElem   \\ \hline
\end{tabular}
\caption{Benchmarks and finitization parameters. Each benchmark is
  named after the class for which data structures are generated; the
  structures also contain objects from other classes.}
\label{fig:benchmarksAndFinitizationParams}
\end{table}

\para
Following is a summary for the implementation of each benchmark : 
\begin{itemize}
\item BinaryTree is our main example we have been using all along. It is an implementation of a Binary tree.
\item HeapArray is an array-based implementation of the heap data structure. This benchmark is representative for array based data structures such as stacks and queues, as well as java.util.Vector.
\item LinkedList is an implementation of linked lists form the Java Collections Framework. This implementation uses doubly-linked, circular lists. The elements in the linked lists are arbitrary objects. This benchmark is also a representative for array based data structures.
\item SortedList is structurally identical to LinkedList but, has sorted elements.
\item RedBlackTree is a binary search tree implementation that self balances itself using a set of rules based on the color in its nodes.
\end{itemize}


\section{Generation of valid structures}
\label{sec:generation-of-valid-structures}
For each benchmark shown in section \ref{sec:benchmarks}, we set all
finitization parameters such that Korat generates structures of upto a
given \emph{size}. We set the \emph{maxSize} and other maximum
parameters to the value of \emph{size} (also known as \emph{scope})
and \emph{minSize} to 0. For a range of sizes and four different
\emph{RepOk} implementations, we tabulate the number of candidate
structures that Korat evaluates, the number of valid structures that
Korat generates and the time Korat takes to output the valid
structures. Figure \ref{fig:resultsTable} presents the results for
generating valid structures for our benchmark suite, using Korat
without reflection support.

\par
\noindent Following is a summary for the implementation of each
\emph{RepOk} used in our evaluation :
\begin{itemize}
\item Field access without reflection : This is \emph{RepOk}
  implementation from the Korat distribution. It doesn't use the Java
  reflection API for any of its field accesses.
\item Reflection used for \emph{root/header} field access : This
  \emph{RepOk} uses reflection to access the \emph{root/header} field
  based on the data structure. This field is a representative for a
  field accessed early in the \emph{RepOk}.
\item Reflection used for \emph{size} field access : This \emph{RepOk}
  uses reflection to access the \emph{size} field that is a
  representative for a field accessed towards the end of the
  \emph{RepOk}.
\item Reflection used for a \emph{recursive} field access : This
  \emph{RepOk} uses reflection to access a \emph{recursive} field in
  the data structure. This field is a representative for a field that
  may be accessed multiple times during the execution of the
  \emph{RepOk}.
\end{itemize}


\para The results in figure \ref{fig:resultsTable} show that korat is
affected differently when reflection is used to access different
fields. In cases where reflection is used to access a field early in
the \emph{RepOk}, the Korat search terminates in under a second and
outputs up to 2 valid structures for the given scopes. In the
\emph{RepOk} where the \emph{size} field accessed using reflection,
Korat evaluates a significantly higher number of candidate structures
but, only outputs very few valid structures. This shows how the Korat
search is affected differently based on the field accessed using
reflection. Korat will be generate all valid non-isomorphic structures
efficiently after we add reflection support to it as discussed in
chapter \ref{ch:adding-reflection}.


\begin{landscape}
%\begin{sidewaystable}[h]
\begin{table}
\resizebox{\columnwidth}{!}{\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
 & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}Field access \\ without reflection\end{tabular}} & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}Reflection used for\\  ``root/header'' field access\end{tabular}} & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}Reflection used for \\ ``size'' field access\end{tabular}} & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}Reflection used for \\ a recursive field access\end{tabular}} \\ \hline
 & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures\\ explored/valid\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}Execution time \\ (in sec)\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures\\ explored/valid\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}Execution time\\ (in sec)\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures\\ explored/valid\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}Execution time\\ (in sec)\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures\\ explored/valid\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}Execution time\\ (in sec)\end{tabular}} \\ \hline
Scope size & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 & 5 & 6 & 7 \\ \hline
BinaryTree & \begin{tabular}[c]{@{}c@{}}1272/\\ 65\end{tabular} & \begin{tabular}[c]{@{}c@{}}4835/\\ 197\end{tabular} & \begin{tabular}[c]{@{}c@{}}18474/\\ 626\end{tabular} & 0.56 & 0.91 & 1.81 & \begin{tabular}[c]{@{}c@{}}7/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}8/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}9/\\ 2\end{tabular} & 0.22 & 0.21 & 0.22 & \begin{tabular}[c]{@{}c@{}}952/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}3659/\\ 7\end{tabular} & \begin{tabular}[c]{@{}c@{}}14099/\\ 8\end{tabular} & 0.49 & 0.72 & 1.41 & \begin{tabular}[c]{@{}c@{}}9/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}10/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}11/\\ 2\end{tabular} & 0.20 & 0.21 & 0.25 \\ \hline
RedBlackTree & \begin{tabular}[c]{@{}c@{}}6073/\\ 115\end{tabular} & \begin{tabular}[c]{@{}c@{}}25938/\\ 327\end{tabular} & \begin{tabular}[c]{@{}c@{}}112012/\\ 911\end{tabular} & 1.36 & 5.32 & 30.32 & \begin{tabular}[c]{@{}c@{}}9/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}10/\\ 2\end{tabular} & \begin{tabular}[c]{@{}c@{}}11/\\ 2\end{tabular} & 0.34 & 0.27 & 0.27 & \begin{tabular}[c]{@{}c@{}}1387/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}4958/\\ 7\end{tabular} & \begin{tabular}[c]{@{}c@{}}18769/\\ 8\end{tabular} & 0.74 & 1.23 & 3.27 & \begin{tabular}[c]{@{}c@{}}16/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}18/\\ 7\end{tabular} & \begin{tabular}[c]{@{}c@{}}20/\\ 8\end{tabular} & 0.30 & 0.31 & 0.32 \\ \hline
LinkedList & \begin{tabular}[c]{@{}c@{}}259/\\ 24\end{tabular} & \begin{tabular}[c]{@{}c@{}}974/\\ 76\end{tabular} & \begin{tabular}[c]{@{}c@{}}4147/\\ 279\end{tabular} & 0.40 & 0.53 & 0.79 & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & 0.22 & 0.23 & 0.23 & \begin{tabular}[c]{@{}c@{}}144/\\ 5\end{tabular} & \begin{tabular}[c]{@{}c@{}}524/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}2201/\\ 7\end{tabular} & 0.29 & 0.45 & 0.65 & \begin{tabular}[c]{@{}c@{}}4/\\ 1\end{tabular} & \begin{tabular}[c]{@{}c@{}}4/\\ 1\end{tabular} & \begin{tabular}[c]{@{}c@{}}4/\\ 1\end{tabular} & 0.22 & 0.23 & 0.25 \\ \hline
SortedList & \begin{tabular}[c]{@{}c@{}}507/\\ 126\end{tabular} & \begin{tabular}[c]{@{}c@{}}2100/\\ 462\end{tabular} & \begin{tabular}[c]{@{}c@{}}9167/\\ 1716\end{tabular} & 0.48 & 0.81 & 1.44 & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & 0.25 & 0.24 & 0.24 & \begin{tabular}[c]{@{}c@{}}71/\\ 5\end{tabular} & \begin{tabular}[c]{@{}c@{}}95/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}122/\\ 7\end{tabular} & 0.29 & 0.31 & 0.34 & \begin{tabular}[c]{@{}c@{}}7/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}8/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}9/\\ 0\end{tabular} & 0.24 & 0.29 & 0.26 \\ \hline
HeapArray & \begin{tabular}[c]{@{}c@{}}8916/\\ 1919\end{tabular} & \begin{tabular}[c]{@{}c@{}}64533/\\ 13139\end{tabular} & \begin{tabular}[c]{@{}c@{}}519968/\\ 117562\end{tabular} & 0.92 & 3.21 & 41.63 & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & \begin{tabular}[c]{@{}c@{}}1/\\ 0\end{tabular} & 0.20 & 0.17 & 0.18 & \begin{tabular}[c]{@{}c@{}}22/\\ 6\end{tabular} & \begin{tabular}[c]{@{}c@{}}26/\\ 7\end{tabular} & \begin{tabular}[c]{@{}c@{}}30/\\ 8\end{tabular} & 0.20 & 0.21 & 0.19 & \begin{tabular}[c]{@{}c@{}}3/\\ 1\end{tabular} & \begin{tabular}[c]{@{}c@{}}3/\\ 1\end{tabular} & \begin{tabular}[c]{@{}c@{}}3/\\ 1\end{tabular} & 0.27 & 0.25 & 0.26 \\ \hline
\end{tabular}}
\caption{Number of valid structures generated by Korat when reflection is used for field accesses. All maximum finitization parameters are set to the size value. Time is elapsed real time in seconds.}
\label{fig:resultsTable}
\end{table}
%\end{sidewaystable}
\end{landscape}

\section{Evaluation of library for predicates}
\label{sec:evaluation-of-library-for-predicates}
This section presents the number of valid structures output by Korat when the
\emph{RepOk} methods use the library for predicates presented in
chapter \ref{ch:library-for-predicates}. Specifically, each
\emph{RepOk} implementation uses the \emph{checkAcyclicity(Object o)}
method to check if the object graph is acyclic. Figure
\ref{fig:libraryEvaluationTable} shows the results of running Korat
with \emph{RepOk} methods from the Korat distribution and the
\emph{RepOk} methods that use the \emph{checkAcyclicity} method. It
was observed that both sets of implementations of \emph{RepOk} methods
evaluate the same number of candidate structures and output the same
number of valid structures. We observed a very negligible (less than 0.1
seconds) execution time difference between the \emph{RepOk}
implementations presented. We believe that the advantages (code reuse,
avoided code bloat) of using the library for predicates for
\emph{RepOk} implentations outweigh the negligible increase in the
execution time.

\begin{table}[h]
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
 & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures \\ explored/valid \\ without a library call\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\# of structures \\ explored/valid \\ with a library call\end{tabular}} \\ \hline
Scope size & 5 & 6 & 7 & 5 & 6 & 7 \\ \hline
BinaryTree & \begin{tabular}[c]{@{}c@{}}1272/\\ 65\end{tabular} & \begin{tabular}[c]{@{}c@{}}4835/\\ 197\end{tabular} & \begin{tabular}[c]{@{}c@{}}18474/\\ 626\end{tabular} & \begin{tabular}[c]{@{}c@{}}1272/\\ 65\end{tabular} & \begin{tabular}[c]{@{}c@{}}4835/\\ 197\end{tabular} & \begin{tabular}[c]{@{}c@{}}18474/\\ 626\end{tabular} \\ \hline
RedBlackTree & \begin{tabular}[c]{@{}c@{}}6073/\\ 115\end{tabular} & \begin{tabular}[c]{@{}c@{}}25938/\\ 327\end{tabular} & \begin{tabular}[c]{@{}c@{}}112012/\\ 911\end{tabular} & \begin{tabular}[c]{@{}c@{}}6073/\\ 115\end{tabular} & \begin{tabular}[c]{@{}c@{}}25938/\\ 327\end{tabular} & \begin{tabular}[c]{@{}c@{}}112012/\\ 911\end{tabular} \\ \hline
LinkedList & \begin{tabular}[c]{@{}c@{}}259/\\ 24\end{tabular} & \begin{tabular}[c]{@{}c@{}}974/\\ 76\end{tabular} & \begin{tabular}[c]{@{}c@{}}4147/\\ 279\end{tabular} & \begin{tabular}[c]{@{}c@{}}259/\\ 24\end{tabular} & \begin{tabular}[c]{@{}c@{}}974/\\ 76\end{tabular} & \begin{tabular}[c]{@{}c@{}}4147/\\ 279\end{tabular} \\ \hline
SortedList & \begin{tabular}[c]{@{}c@{}}507/\\ 126\end{tabular} & \begin{tabular}[c]{@{}c@{}}2100/\\ 462\end{tabular} & \begin{tabular}[c]{@{}c@{}}9167/\\ 1716\end{tabular} & \begin{tabular}[c]{@{}c@{}}507/\\ 126\end{tabular} & \begin{tabular}[c]{@{}c@{}}2100/\\ 462\end{tabular} & \begin{tabular}[c]{@{}c@{}}9167/\\ 1716\end{tabular} \\ \hline
\end{tabular}
\caption{Number of valid structures generated by Korat when library for predicates is used in RepOk. All maximum finitization parameters are set to the size value.}
\label{fig:libraryEvaluationTable}
\end{table}
