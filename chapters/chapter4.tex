\chapter{Static analysis to check predicate}
\label{ch:static-analysis}
This chapter presents our static analyzer RepOkValidator.  It takes as
input a \emph{RepOk} method, and analyzes it to detect whether the \emph{RepOk}
method may potentially be re-written by the user to improve Korat's
performance; in addition, RepOkValidator identifies parts of \emph{RepOk},
which provide hints to the user about where to edit it.

Section~\ref{sec:static-analysis-conditions} presents the conditions
that form the basis of RepOkValidator's analysis.
Section~\ref{sec:repokvalidator} describes the basic RepOkValidtor
analysis and its implementation.  Finally,
Section~\ref{sec:static-analysis-example} presents an example of a poorly-written
\emph{RepOk} method and the logs generated by the RepOkValidator for
that method.

\section{Conditions}
\label{sec:static-analysis-conditions}
Recall from Chapter~\ref{ch:shortcomings-of-korat}, the execution of
Korat search is sensitive to the way the predicate is written by the
user and a \emph{RepOk} that does not return the result as soon as
possible may affect the number of structures pruned by Korat.

For correct functionality, Korat requires\cite{marinov2005automatic}
that the following conditions hold for the \emph{RepOk} method:

\begin{aquote}{Darko Marinov~\cite{marinov2005automatic}}
$C1$: Each execution of the predicate terminates, and either returns a
true or a false.\\ 
$C2$: No execution of the predicate depends on the actual allocation
address of the candidate object or its fields.(This holds for java
predicates if no execution invokes \emph{System.identityHashCode}
method.)\\ 
$C3$: Each field that the predicate accesses is either a part of the
candidate structure or a field of some object that the predicate
locally allocates. In other words, the execution does not access
global data through static fields.\\
\end{aquote}

While these conditions are required for correct input/output behavior
of Korat, its performance can depend on various other conditions.  We
focus on a special class of \emph{RepOk} methods, which tend to cause
Korat to perform poorly, e.g., as shown in the \emph{RepOk} in
Figure~\ref{fig:repOkMultipleBooleanVariables}.  Specifically, these
methods use local boolean flags to track data structure properties
being checked and when a property violation is determined, set the
corresponding flag to false, rather than returning false immediately.
Our analysis checks the given \emph{RepOk} with respect to the
following 3 conditions:

\begin{itemize}
\item $C4$: If the return value of the predicate at control point $c$ is
  a local boolean flag, it is set at most once between the time of its
  declaration and its return along any path of execution to $c$;
\item $C5$: If the return value is a conjunction or a disjunction of
  multiple local boolean flags at control point $c$, each flag is set
  at most once during the time between its declaration and usage in
  deciding the return value at $c$; and
\item $C6$: No fields are accessed between the time of setting the
  return value and the actual return of the value.
\end{itemize}

Thus, if the conditions $C4--C6$ hold for a given \emph{RepOk} that uses
local boolean flags, our analyzer considers that \emph{RepOk} as
\emph{validated} -- intuitively such a \emph{RepOk} is likely to give
expected performance using Korat.  Moreover, if $C4$ (or $C5$) hold
but $C6$ is violated, the user can re-write \emph{RepOk} by returning the
result earlier such that $C6$ holds to potentially improve Korat's
performance.  Furthermore, if $C4$ and $C6$ are both violated but the
flag is only set to false (repeatedly), the user may still be able to
re-write \emph{RepOk} by returning earlier, say each control points where
$C4$ is violated.  Note the RepOkValidator only provides hints on how
the user may re-write \emph{RepOk} but does not guarantee that a re-write
that optimizes Korat's performance exists.

\section{RepOkValidator}
\label{sec:repokvalidator}
The RepOkValidator analyzers its input \emph{RepOk} to check the conditions
$C2--C6$.  The analyzer prints a log of all the violations it detects.
The log can help the user to edit the \emph{RepOk} for better performance.
In addition, RepOkValidator localizes condition violations in the
predicate code to make it easier for the user to fix them.  Note that
violations of type C2 and C3 need to be fixed before using the
predicate with Korat as they may affect the number of valid structures
generated by Korat. In contrast, violations of type C4--C6 do not
affect the correctness of Korat's output and only affect its
performance.

\para To detect the violations, we build \emph{def-use} chains of the
local boolean flags in the predicate. We also collect data about all
method invocations, including the parameters used to invoke the
methods. Once we have this data, the RepOkValidator traverses the
def-use chains to detect violations of $C4--C6$ and logs them.

\subsection{Implementation}
\label{sec:implementation}
Our implementation of RepOkValidator uses Soot~\cite{vallee1999soot},
a Java bytecode optimization framework. The framework is implemented
in Java and supports three intermediate representations of java
bytecode. RepOkValidator uses the intermediate representation called
\emph{Jimple} as it is a useful representation for static analysis.
Jimple is a 3-address code representation of bytecode, which is typed
and does not include the 3 address code equivalent of a \emph{jsr}
(jump to subroutine) instructions.

\para The RepOkValidator takes the data structure that needs to be
analyzed as a command line argument and passes the argument on to
Soot, which converts the class into Jimple. Once the code is converted
to Jimple, the RepOkValidator looks for all the instance methods that
return a \emph{boolean}, have a method name that starts with
\emph{RepOk} and take no arguments. For each such method, the
RepOkValidator does intraprocedural analysis to extract the def-use
chains of all variables in the method. Finally, the RepOkValidator
validates the predicate by checking for violations of conditions
$C2--C6$ and adds any violations found to the violation log for userâ€™s
reference.

\para If no violation is detected, the RepOkValidator prints that the
predicate passed the test.

\section{Example}
\label{sec:static-analysis-example}
In this section, we apply RepOkValidator to an example \emph{RepOk} method,
which is poorly-written.  Figure
\ref{fig:repOkMultipleBooleanVariables} shows the example \emph{RepOk}
for binary trees.  This \emph{RepOk} does not violate conditions
$C1--C3$.  Therefore, Korat outputs all valid non-isomorphic
structures when this \emph{RepOk} is used but it ends up evaluating
too many candidate structures during its search.  This \emph{RepOk} violates
conditions $C5$ and $C6$.  RepOkValidator detects these violations.
The \emph{RepOk} violates $C5$ because the \emph{boolean} variable
\emph{acyclic} is set twice along some paths before it is returned.
It also violates $C6$ as there are multiple field accesses made after
setting the value of the variable \emph{acyclic} and before it is
actually returned as a part of the result for the \emph{RepOk} method.
Using this \emph{RepOk} makes Korat's generation highly inefficient compared
to a short-circuiting \emph{RepOk} (Figure~\ref{fig:btreeDirectRepOk}).


\begin{figure}
\centering
\begin{lstlisting}[language=Java]
boolean repOKMultipleVariables() {
    boolean sizeOk = true, acyclic = true;
    // checks that empty tree has size zero.
    if (root == null) sizeOk = (size == 0);
    Set visited = new HashSet();
    if(root != null) visited.add(root);
    LinkedList workList = new LinkedList();
    if(root != null) workList.add(root);
    // loop checks that the object graph is a tree.
    while (!workList.isEmpty()) {
        Node current = (Node) workList.removeFirst();
        if (current.left != null) {
            if (!visited.add(current.left)) 
                acyclic = false;
            else workList.add(current.left);
        }
        if (current.right != null) {
            if (!visited.add(current.right)) 
                acyclic = false;
            else workList.add(current.right);
        }
    }
    // checks that the size is consistent.
    return acyclic && sizeOk 
           && (visited.size() == size);  
}
\end{lstlisting}
\caption{RepOk that uses multiple boolean variables to decide its result. It violates $C5$ and $C6$.}
\label{fig:repOkMultipleBooleanVariables}
\end{figure}


\para Figure~\ref{fig:repOkKoratSatisfyEfficiencyLog} shows the
violation log that RepOkValidator generates for the \emph{RepOk} shown
in Figure~ \ref{fig:repOkMultipleBooleanVariables}.

\begin{figure}
\centering
\begin{lstlisting}[language=Java]
- Analyzing repOKMultipleVariables from edu.utexas.BinaryTree -
Condition C5 violated : redefinition of field acyclic at line 91 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - left after defining return value from class edu.utexas.BinaryTree$Node at line 87 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - right after defining return value from class edu.utexas.BinaryTree$Node at line 89 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - right after defining return value from class edu.utexas.BinaryTree$Node at line 90 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - right after defining return value from class edu.utexas.BinaryTree$Node at line 92 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - size after defining return value from class edu.utexas.BinaryTree at line 96 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
// More Logs ...
- repOKMultipleVariables did not pass the test -
\end{lstlisting}
\caption{Violation log generated by the RepOkValidator when the inefficient repOk is analyzed.}
\label{fig:repOkKoratSatisfyEfficiencyLog}
\end{figure}

The user can inspect the log and the lines numbers that are reported
in condition violations to determine how to re-write the \emph{RepOk} so the
reported conditions are no longer violated.
