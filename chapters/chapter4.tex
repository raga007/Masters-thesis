\chapter{Static analysis to check predicate}
\label{ch:static-analysis}
This chapter presents a static analysis tool (we call it the RepOkValidator) to check the predicate written by the user to use with Korat. A predicate is a piece of code that takes an input (a candidate structure in our case) and returns a boolean that represents, if the predicate has a proper representation. Our tool will statically analyze the predicate written by the user and point out places where it can be changed to optimize the execution of Korat when the predicate is used with Korat.

\section{Conditions}
\label{sec:static-analysis-conditions}
As we have seen in chapter \ref{ch:shortcomings-of-korat}, the execution of Korat is partly dependant on the predicate written by the user. A repOk that doesn’t return the result as soon as possible, will end up heavily affecting the pruning mechanism of Korat. Korat requires\cite{marinov2005automatic} that the following conditions hold good for a user written predicate - 

\begin{aquote}{Darko Marinov}
C1 : Each execution of the predicate terminates, and either returns a true or a false.\\
C2 : No execution of the predicate depends on the actual allocation address of the candidate object or its fields.(This holds for java predicates if no execution invokes \emph{System.identityHashCode} method.)\\
C3 : Each field that the predicate accesses is either a part of the candidate structure or a field of some object that the predicate locally allocates. In other words, the execution does not access global data through static fields.\\
\end{aquote}

\para
It is possible to make a guarantee about the Korat’s efficiency (the number of candidates considered by Korat) if the user written predicate follows the conditions below, in addition to the conditions specified by Korat. In other words, the following conditions only affect the efficiency of Korat, unlike C1-C3 which affect the correctness of the output generated by Korat. The following conditions assume that a fixed amount of space (variable length data structures like boolean arrays/lists are not used) is allocated for the booleans used by the predicate. 
\begin{itemize}
\item C4 : If the return value of the predicate is a variable then, it is set at most once between the time of its declaration and its return along any path of execution.
\item C5 : If the return value is a conjunction or a disjunction of multiple boolean variables then, each variable is set at most once during the time between its declaration and usage in deciding the return value.
\item C6 : No fields are accessed (chapter \ref{ch:adding-reflection} describes a way to access the fields without Korat accounting for the access) between the time of setting the return value and the actual return of the value.
\end{itemize}

\para
The above conditions were derived from observing the results of executions of Korat with various predicates that resulted in the same valid structures but considered different number of candidate structures.

\section{Choosing static analysis over dynamic analysis}
\label{sec:choosing-static-over-dynamic}
Given a predicate, it is possible to use a static or dynamic analysis of the predicate to derive detailed information about the predicate. The user of Korat needs to write a predicate so that conditions C1-C3 hold so that Korat works correctly. The user also can optionally make sure that C4-C6 hold to ensure that Korat takes the least amount of time possible to execute. 

\para
Dynamic analysis is the testing and evaluation of a piece of code during runtime. Dynamic analysis reveals subtle faults whose cause is often complex to be discovered by static analysis. It is usually more time consuming than a static analysis. Static analysis is the testing and evaluation of a piece of code by examining it, without executing it. It examines all possible execution paths and variable values, not just those invoked during execution. The only condition that can’t be checked is C1, as it is the halting problem. Since every other condition can be checked using a static analysis, we decided to use static analysis over dynamic analysis in the interest of avoiding the execution time overhead of dynamic analysis.

\section{RepOkValidator}
\label{sec:repokvalidator}
The RepOkValidator is a static analysis tool that will analyze the predicate written by the user. It will print all the violations in the form of a log. The log can help the user to ensure that the predicate will execute in the least amount of time possible, when used with Korat. In other words, the RepOkValidator will print violations of conditions C2-C6 and localize them in the predicate to make it easier for the user to fix the violations. It is important to understand that violations of type C2 and C3 need to be fixed before using the predicate with Korat. Korat requires that condition C1-C3 hold good for it work properly. On the other hand, It is optional for the user to fix violations of type C4-C6 as they just affect the efficiency of Korat as opposed to the correctness. As of today, the RepOkValidator is a standalone tool that can optionally be used by the user to validate the predicate written before using it with Korat.

\para
For each condition to hold good, the RepOkValidator needs to look for specific violations of the conditions in the predicate. 
\begin{itemize}
\item C2 : will be violated if the predicate written by the user invokes the System.identityHashCode method.
\item C3 : will be violated if any fields accessed in the predicate don’t belong to the candidate class or the fields accessed are static.
\item C4 : will be violated if the return value is assigned a value more than once, from the time it is defined to the time it is returned, in any path of execution.
\item C5 : will be violated if any of the variables that make up the result are assigned a value more than once from the time they are defined to the time they are returned, in any path of execution.
\item C6 : will be violated if any of the candidate class fields are accessed once all of the fields that make up the return value are assigned a value.
\end{itemize}

\para
To be able to detect the violations, we build def-use chains and use-def chains of all variables in the predicate. We also collect data about all method invocations, including the parameters used to invoke the methods. Once we have this data, RepOkValidator traverses the use-def and def-use chains to detect violations and logs them for user reference.

\section{Implementation}
\label{sec:implementation}
The implementation of RepOkValidator uses Soot ~/cite{..}, a java bytecode optimization framework. The framework is implemented in Java and support three intermediate representations of java bytecode. RepOkValidator uses the intermediate representation called Jimple as it is an ideal representation for static analysis. Jimple is a 3-address code representation of bytecode, which is typed and does not include the 3 address code equivalent of a jsr (jump to subroutine) instructions.

\para
The RepOkValidator takes the data structure that needs to be analyzed as a command line argument and passes the argument on to Soot, for it convert the class into jimple. Once the code is converted to jimple, the RepOkValidator looks for all the methods that return a boolean and have a method name that starts with repOk and take no arguments. For each such method, the RepOkValidator does intraprocedural analysis to extract the def-use and use-def chains of all variables in the method. After extracting the def-use and use-def chains, RepOkValidator sequentially validates the predicate for each condition in C2-C6 and adds violations to the violation log for user’s reference.

\para
Finally, if the violation log is empty, the RepOkValidator prints that the predicate passed the test. This means that the predicate will work with Korat and will also help Korat perform efficiently.

\section{Example}
\label{sec:static-analysis-example}
In this section, we will be looking at two predicates written for a BinaryTree shown in figure \ref{fig:btreeDirectRepOk}. The first example will show a faulty predicate that will not work with Korat as it doesn’t obey conditions C2 and C3. The second example will show an inefficient predicate which will work with Korat but can be optimized using the log messages produced by the RepOkValidator.

\subsection{Faulty Predicate}
\label{sec:faulty-predicate}
Figure \ref{fig:repOkKoratSatisfyCorrectness} shows a repOk that a user can write to generate non-isomorphic BinaryTree structures. The repOk won't reliably work with Korat as it violates the conditions that need to be fulfilled for Korat to function properly. To be specific, the repOk violates condition C3 from section \ref{sec:static-analysis-conditions}. It violates C3 by using the MAX\_SCOPE\_PARAM field from the Settings class (shown in figure \ref{fig:repOkKoratSatisfyCorrectness}).The field can be changed during the Korat search and hence will make the Korat search return wrong/incomplete results, if changed to a different value.

\begin{figure}
\centering
\begin{lstlisting}[language=Java]
public class Settings {
    public static int MAX_SCOPE_PARAM = 3;
}

boolean repOKFaulty() {
    //makes sure the size is not more than limit
    if (size > Settings.MAX_SCOPE_PARAM) 
        return false;
    // checks that empty tree has size zero.
    if (root == null) return size == 0;
    Set visited = new HashSet();
    visited.add(root);
    LinkedList workList = new LinkedList();
    workList.add(root);
    // loop checks that the object graph is a tree.
    while (!workList.isEmpty()) {
        Node current = (Node) workList.removeFirst();
        if (current.left != null) {
            if (!visited.add(current.left))
                return false;
            workList.add(current.left);
        }
        if (current.right != null) {
            if (!visited.add(current.right))
                return false;
            workList.add(current.right);
        }
    }
    // checks that the size is consistent.
    return (visited.size() == size);
}

\end{lstlisting}
\caption{RepOk that doesn’t work with Korat as it doesn’t satisfy condition C3.}
\label{fig:repOkKoratSatisfyCorrectness}
\end{figure}

\para
When the predicate is analyzed using the RepOkValidator, it prints a log of the violations that need to be fixed by the user to make sure Korat functions properly when the repOk is used with Korat. Figure \ref{fig:repOkKoratSatisfyCorrectnessLog} shows the logs printed by the RepOkValidator. Each log will mention the kind of the violation, the line number at which the violation is made, the predicate method inside which the violation is made and the class to which the repOk belongs to. Since all the violations shown by figure \ref{fig:repOkKoratSatisfyCorrectnessLog} belong to C1-C3, it is important that the user fixes all the violations to ensure that Korat will function properly with the predicate.

\begin{figure}
\centering
\begin{lstlisting}[language=Java]
-------------- Analyzing repOkFaulty from edu.utexas.BinaryTree ------------
Condition C3 violated : usage of a static field - MAX_SCOPE_PARAM from class edu.utexas.BinaryTree$Settings at line 54 inside repOKEfficient in edu.utexas.BinaryTree
------------ repOkFaulty did not pass the test ------------
\end{lstlisting}
\caption{Violation log generated by the RepOkValidator when the faulty repOk is analyzed.}
\label{fig:repOkKoratSatisfyCorrectnessLog}
\end{figure}

\subsection{Inefficient Predicate}
\label{sec:inefficient-predicate}
Figure \ref{fig:repOkMultipleBooleanVariables} shows another repOk that the programmer can write to generate non-isomorphic BinaryTree structures. This time the repOk works with Korat as it does not violate conditions C1-C3. Even though the repOk generated all valid non-isomorphic structures when used with Korat, it considered way too many candidate structures to generate them. This is because the predicate violates conditions C5 and C6. Since violating conditions C4-C6 affects the efficiency of Korat, it is observed that the execution of Korat with this predicate takes more time compared to the predicate in figure \ref{fig:btreeDirectRepOk}, which passes the RepOkValidator test.

\para
The repOk violates C5 because the boolean variable acyclic is defined twice before it is returned. Since the result of the predicate depends on the variable, it is possible to return the result right after setting the value of acyclic for the first time. It also violated C6 as there are multiple field references after setting the value of the variable acyclic and before it is actually returned as a result for the predicate.

\begin{figure}
\centering
\begin{lstlisting}[language=Java]
boolean repOKMultipleVariables() {
    boolean sizeOk = true, acyclic = true;
    // checks that empty tree has size zero.
    if (root == null) sizeOk = (size == 0);
    Set visited = new HashSet();
    visited.add(root);
    LinkedList workList = new LinkedList();
    workList.add(root);
    // loop checks that the object graph is a tree.
    while (!workList.isEmpty()) {
        Node current = (Node) workList.removeFirst();
        if (current.left != null) {
            if (!visited.add(current.left)) acyclic = false;
            else workList.add(current.left);
        }
        if (current.right != null) {
            if (!visited.add(current.right)) acyclic = false;
            else workList.add(current.right);
        }
    }
    // checks that the size is consistent.
    return acyclic && sizeOk && (visited.size() == size);  
}
\end{lstlisting}
\caption{RepOk that uses multiple boolean variables to decide its result. It violates C5 and C6 and ends up affecting the efficiency of Korat.}
\label{fig:repOkMultipleBooleanVariables}
\end{figure}

\para
It is also worth noticing that multiple boolean variables go into deciding the result of the predicate. This is very common for complex, recursive data structures like the BinaryTree. In situations like this, the RepOkValidator proves to be extremely useful as it exactly points out the places at which the violations are made. Once the programmer knows the places at which the violations are made, it should be straightforward to fix the predicate to ensure maximum efficiency. Figure \ref{fig:repOkKoratSatisfyEfficiencyLog} shows the violation log that gets generated when the repOk shown in figure \ref{fig:repOkMultipleBooleanVariables} is analyzed with the RepOkValidator.

\begin{figure}
\centering
\begin{lstlisting}[language=Java]
-------------- Analyzing repOKMultipleVariables from edu.utexas.BinaryTree ------------
Condition C5 violated : redefinition of field acyclic at line 91 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - left after defining return value from class edu.utexas.BinaryTree$Node at line 87 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - right after defining return value from class edu.utexas.BinaryTree$Node at line 89 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - right after defining return value from class edu.utexas.BinaryTree$Node at line 90 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - right after defining return value from class edu.utexas.BinaryTree$Node at line 92 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
Condition C6 violated : usage of a field - size after defining return value from class edu.utexas.BinaryTree at line 96 inside repOKMultipleVariables in edu.utexas.BinaryTree.java
// More Logs ...
------------ repOKMultipleVariables did not pass the test ------------
\end{lstlisting}
\caption{Violation log generated by the RepOkValidator when the inefficient repOk is analyzed.}
\label{fig:repOkKoratSatisfyEfficiencyLog}
\end{figure}
