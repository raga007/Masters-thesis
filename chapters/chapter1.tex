\chapter{Introduction}
Testing plays a vital role in developing reliable systems. However, testing manually is expensive and tedious. Researchers have long recognized the benefits of using specifications in automated testing~\cite{...}. While the initial use of specifications was largely in academic settings, the last fifteen years have seen much progress in developing tools that can make use of specifications to test real applications, e.g., by generating test inputs automatically using constraint solving \cite{demilli1991constraint,gotlieb1998automatic,howden1977symbolic,huang1975approach,king1976symbolic,korel1996automated,legeard2002automated,marinov2001testera}.

\para
The focus of our work is test input generation using imperative predicates, which was introduced by the \emph{Korat} approach \cite{boyapati2002korat}. Korat takes a given Java method, called \emph{repOk}, that returns a \emph{boolean} method, and systematically explores the input space of the predicate to enumerate inputs for which \emph{repOk} returns \emph{true}. The focus of Korat’s generation is structurally complex data, e.g., recursive data structures allocated on the program heap. The input spaces to explore for such recursive structures are often huge.  Korat performs a bounded exploration defined by a \emph{finitization} given by the user to bound the input size. Korat efficiently prunes the space of candidate inputs for the \emph{repOk} method by executing it on candidate inputs and monitoring the object fields that \emph{repOk} accesses in deciding if the properties are satisfied. Moreover, Korat prunes from search candidates that are isomorphic to any candidate already evaluated, thereby further reducing the number of candidates to consider by a considerable factor.

\para
While Korat generates inputs effectively, its correctness and efficiency rely on two assumptions about the \emph{repOk} methods.  For correctness, Korat assumes the \emph{repOk} methods do not use the Java reflection API for field accesses; the use of reflection renders Korat unable to enumerate all desired inputs.  For efficiency, Korat assumes the \emph{repOk} methods are written such that they only access fields that are necessary to check the properties; the use of unnecessary field accesses by \emph{repOk} renders Korat's pruning ineffective.

\para
In this thesis, we address both these limitations.  To support reflection, we build on the core Korat to enhance it such that it can monitor field accesses based on reflection.  To deal with unnecessary field accesses, we present a tool called \emph{RepOkValidator} that points out such field accesses so that the user can choose to fix them to enhance Korat’s performance.


\section{Korat : A solver for imperative predicates}

A \emph{constraint} is a formula that specifies some property of a set
of variables. For example, the constraint \emph{x \textgreater 0 \&\&
  x \textless 10}, specifies that the value of \emph{x} needs to be
between zero and ten. \emph{Constraint solving} amounts to finding
solutions to constraints, i.e assignments to variables that make the
constraint formula true. For example, \emph{x = 5} is a solution for
the above constraint formula. 

The main idea in \emph{constraint-based test input generation} is to
represent the property of the desired test inputs as a constraint such
that the solution to the constraint represents a test input. While
there are several previous approaches for constraint-based input
generation, most address porgram with inputs that are integers or
arrays of integers
\cite{demilli1991constraint,huang1975approach,king1976symbolic,korel1996automated},
or required constraints to be written in a declarative
language~\cite{TestEra}. Korat \cite{boyapati2002korat} is the first
solver for constraints that represent structurally complex inputs and
are written in an imperative language, namely Java.

\para Korat solves a constraint expressed as an \emph{imperative
  predicate}, which is a Java method that conceptually inspects its
input structure for validity and returns a boolean value based on
whether the input satisfies the desired structural constraint or not.
Thus, solving an imperative predicate amounts to finding input
structures for which the predicate returns \emph{true}.  Imperative
predicates give the user an operational way of expressing declarative
constraints that identify the desired test inputs.  Every valid
structure represents a desired test input.

\para Korat takes as an input a Java \emph{predicate} and a
\emph{finitization} that bounds the size of the input structures to
generate.  Korat outputs all valid \emph{nonisomorphic} structures
within the given bounds. A finitization specifies upper bounds for the
number of objects for different types in the structure and the
possible values for the fields of these objects. Korat generates all
valid structures by systematically searching the structure space
defined by the finitization. Korat prunes the search space by
monitoring the execution of the predicate on each candidate structure
considered and determining the fields of the structure accessed by the
predicate before it returns the result. For exhaustive generation,
Korat backtracks on the last field that is accessed by RepOk.  The
efficiency of Korat's pruning is sensitive to the way the imperative
predicate is written. For example, an ill-written predicate may always
read all the reachable fields of a structure even after it is
determined to be invalid before returning false, thereby forcing Korat
to potentially backtrack much later than it would otherwise have if
the predicate had returned false earlier (when fewer fields were
accessed).  In chapter 2, we will see an example of this behavior.

\section{Allowing the use of reflection in RepOk methods}

Reflection~\cite{...} is a powerful mechanism that allows
introspection of a Java program.  The Java reflection API makes it
possible to inspect classes, interfaces, fields and methods at
runtime, without knowing the names of the classes, methods etc. at
compile time. It also allows instantiating new objects, invoking
methods and getting/setting field values.  If the RepOk accesses
object fields using reflection, the original implementation of Korat
does not have a way to observe those accesses.  Since Korat prunes its
search by monitoring RepOk's field accesses, Korat's backtracking is
affected by the use of reflection and Korat erroneously may not
generate some valid structues.  We present a technique that builds on
Korat to allow the use of reflection for field accesses by RepOk.

\begin{comment}
\noindent Formally, reflection can be split into three main aspects \cite{bracha2004mirrors,mostinckx2009mirror}:
\begin{itemize}
\item \emph{Introspection}: the ability of a program to examine itself.
\item \emph{Self-modification}: the ability of a program to alter its structure.
\item \emph{Intercession}: the ability of a program to alter its behaviour.
\end{itemize}

\para Unfettered run-time modification of a system is dangerous, since
it can have subtle, unintended consequences. However careful use of
reflection allows programmers to bend a language to their particular
circumstances rather than the other way round. Most dynamically typed
languages are capable of introspection; many are capable of
self-modification; relatively few are capable of intercession. Korat
is primarily written in Java which is a statically typed language that
only supports the introspective \cite{maes1987concepts} aspects of
reflection.Java Reflection makes it possible to inspect classes,
interfaces, fields and methods at runtime, without knowing the names
of the classes, methods etc. at compile time. It is also possible to
instantiate new objects, invoke methods and \emph{get/set} field
values using reflection.

\para
Korat monitors the field accesses made by the imperative predicate written by the user and prunes the search space accordingly. Since java supports field access using reflection, it is important to make sure that Korat also monitors field accesses using reflection. This property will become more useful when Korat is implemented in a dynamically typed language like ruby/python. 
\end{comment}

\section{Static analysis to detect poorly written RepOk methods}
Since the effectiveness of Korat's pruning relies heavily on RepOk's
field accesses, a poorly written RepOk may render Korat impractical to
use.  We present a static analysis, namely \emph{def-use} analysis,
that detects a certain pattern for poorly written RepOk's.  Our tool
RepOkValidator implements the analysis, which is described in more
detail in Chapter~\ref{ch:static-analysis}.

\begin{comment}
A DEF-USE
ANALYSIS IS A DATA-FLOW Analysis Which Helps In Statically
accumulating def-use and use-def chains. 

Specifically, we utilize use-def chains, where each chain is a data
structure that consists of a use, U, of a variable, and all the
definitions, D, of that variable that can reach that use without any
other intervening definitions. 

Once the RepOkValidator has access to the use-def chain of the
predicate, it checks the chain to see if a few properties (mentioned
in chapter 4) that affect Korat’s efficiency are not violated.


Static program analysis is the analysis of a piece of code without
actually executing the piece of code. The sophistication of the
analysis performed by different tools varies from those that only
consider the behavior of individual statements and declarations, to
those that include the complete source code of a program in their
analysis.

a badly written predicate can deteriorate the efficiency of
Korat, we propose a static analysis of the predicate to identify
places (if any) where the predicate can be improved. Chapter 4
presents \emph{RepOkValidator}, a tool that uses \emph{def-use}
analysis to check if the predicate written by the user affects the
efficiency of Korat.
\end{comment}


We make the following contributions:

\begin{itemize}
\item 
\item 
\item 
\end{itemize}

\section{Organization}
The remainder of this thesis is organized as follows. Chapter 2 illustrates with examples, scenarios where Korat underperforms. Chapter 3 talks about adding reflection to Korat. Chapter 4 presents a static analysis tool that can be used to validate a predicate written by the user. Chapter 5 presents a small library that can be used for code reuse in predicates. Chapter 6 compares usage of predicates that use reflection and a predicate that does not use reflection, with Korat and shows how Korat performs when reflection is not supported. Chapter 7 discusses other approaches that people have used to improve Korat and also suggests some future work.
