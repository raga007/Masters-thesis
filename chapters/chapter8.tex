\chapter{Conclusion and Future work}
\label{ch:future-work}
\section{Conclusion}
We developed two techniques to improve the previously developed Korat
tool for test input generation using imperative constraints that
describe properties of desired inputs written as Java predicates,
termed \emph{RepOk} methods.  A \emph{RepOk} is an executable check
for the desired properties.  Korat efficiently prunes the space of
candidate inputs for the \emph{RepOk} method by executing it on
candidate inputs and monitoring the object fields that \emph{RepOk}
accesses in deciding if the properties are satisfied.  While Korat
generates inputs effectively, its correctness and efficiency rely on
two assumptions about the repOk methods.  For correctness, Korat
assumes the \emph{RepOk} methods do not use the Java reflection API
for field accesses; the use of reflection renders Korat unable to
enumerate all desired inputs.  For efficiency, Korat assumes the
\emph{RepOk} methods are written such that they only access fields
that are necessary to check the properties; the use of unnecessary
field accesses by \emph{RepOk} renders Korat's pruning ineffective.
Our work addressed both these limitations.  To support reflection, we
built on the core Korat to enhance it such that it can monitor field
accesses based on reflection.  To deal with unnecessary field
accesses, we introduced a static analysis tool that points out
unnecessary filed accesses in \emph{RepOk} methods. Experimental
results using a suite of standard data structure subjects show the
effectiveness of our approach.



\section{Future work}
Korat requires the user to provide an imperative predicate. In Java an imperative predicate is a method that takes an input structure and returns a \emph{boolean}. Aditionally, the user provides a finitization that bounds the number of objects in the structure and the values for the fields of those objects. Korat then generates all nonisomorphic structures, within the bounds for which the predicate returns true. The structures that Korat generates form a basis for bounded exhaustive testing. We next present several ideas for extending the work on Improvised Korat.

% This thesis has presented a technique to build on Korat instrumentation to support usage of the Java reflection API in imperative predicates, a static analysis tool called RepOkValidator to validate the imperative predicates written by the user and a library that can be used to write short and efficient predicates.

\para
\textbf{RepOkValidator as a standalone tool} : The RepOkValidator presented in chapter \ref{ch:static-analysis} is currently a Java project. It would be very useful to add a GUI to the project and release it as a standalone tool, that can be used with Korat to ensure the efficiency of Korat search.

\para
\textbf{Implement reflection instrumentation} : In chapter \ref{ch:adding-reflection} we presented a technique to build on Korat instrumentation to support usage of reflection but, all our experiements were done using the \emph{getFieldValue} method from section \ref{sec:adding-reflection-to-instrumentation}. To enable the seamless usage of Java reflection API with Korat, it is important to modify the Korat instrumentation and make it replace all Java reflection method calls with the \emph{getFieldValue} method.

\para
\textbf{Context based test generation} : Korat by default generates all non-isomorhic structures upto a given bound provided by the finitization provided by the user. One approach to reduce the number of structures is to consider non-exhaustive generation based on the context. This will help make Korat both quicker and more intelligent. For example, if the application under test is going to be a web application, Korat can choose to generate only boundary tests (tests that can make the system break, in general), as opposed to generating all functionality tests.

\para
\textbf{Continuous integeration with Korat} : It would be interesting to do continous integeration \cite{fowler2006continuous} with Korat. Korat can automatically generate all non-isomorphic test inputs for methods that involve code changes. If a test generated by Korat fails, the code change can simply be rejected and programmer can be notified about the test case failure. This way, Korat can be used to make sure the build that is currently live is never broken.





