\chapter{Future work}
\label{ch:future-work}
Korat requires the user to provide an imperative predicate. In Java an imperative predicate is a method that takes an input structure and returns a \emph{boolean}. Aditionally, the user provides a finitization that bounds the number of objects in the structure and the values for the fields of those objects. Korat then generates all nonisomorphic structures, within the bounds for which the predicate returns true. The structures that Korat generates form a basis for bounded exhaustive testing. This thesis has presented a technique to build on Korat instrumentation to support usage of the Java reflection API in imperative predicates, a static analysis tool called RepOkValidator to validate the imperative predicates written by the user and a library that can be used to write short and efficient predicates. We next present several ideas for extending the work on Improvised Korat.

\para
\textbf{RepOkValidator as a standalone tool} : The RepOkValidator presented in chapter \ref{ch:static-analysis} is currently a Java project. It would be very useful to add a GUI to the project and release it as a standalone tool, that can be used with Korat to ensure the efficiency of Korat search.

\para
\textbf{Implement reflection instrumentation} : In chapter \ref{ch:adding-reflection} we presented a technique to build on Korat instrumentation to support usage of reflection but, all our experiements were done using the \emph{getFieldValue} method from section \ref{sec:adding-reflection-to-instrumentation}. To enable the seamless usage of Java reflection API with Korat, it is important to modify the Korat instrumentation and make it replace all Java reflection method calls with the \emph{getFieldValue} method.

\para
\textbf{Context based test generation} : Korat by default generates all non-isomorhic structures upto a given bound provided by the finitization provided by the user. One approach to reduce the number of structures is to consider non-exhaustive generation based on the context. This will help make Korat both quicker and more intelligent. For example, if the application under test is going to be a web application, Korat can choose to generate only boundary tests (tests that can make the system break, in general), as opposed to generating all functionality tests.

\para
\textbf{Continuous integeration with Korat} : It would be interesting to do continous integeration \cite{fowler2006continuous} with Korat. Korat can automatically generate all non-isomorphic test inputs for methods that involve code changes. If a test generated by Korat fails, the code change can simply be rejected and programmer can be notified about the test case failure. This way, Korat can be used to make sure the build that is currently live is never broken.

\para
\textbf{Imperative predicate synthesis} : Currently Korat requires the user to provide an imperative predicate that validates the representation invariant. We could consider synthesizing this predicate automatically from the code under test and/or existing test cases already provided by the user. Pacheco and Earnst developed Eclat \cite{pacheco2005eclat} a tool that automatically generates additional test inputs from a given set of test inputs and the code under test. Eclat builds on Daikon \cite{ernst2007daikon}, a tool that dynamically detects likely program invariants, to generate likely predicates from the given tests. Korat can be combined with Eclat to possibly support automatic test generation with just a finitization.





